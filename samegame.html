<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1976d2">
    <meta name="description" content="BirdNET Same Game - Remove connected bird groups in this classic puzzle game">
    <title>BirdNET Same Game</title>
    
    <link rel="manifest" href="#" id="manifest-placeholder">
    <link rel="stylesheet" href="common.css">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: clamp(10px, 2vw, 30px);
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: min(1400px, 95vw);
            width: 100%;
            display: flex;
            gap: clamp(15px, 2vw, 25px);
            align-items: flex-start;
        }

        header {
            background: white;
            padding: clamp(15px, 2vw, 25px);
            border-radius: clamp(6px, 1vw, 12px);
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
            flex: 0 0 auto;
            width: clamp(220px, 28vw, 320px);
            position: sticky;
            top: 20px;
            align-self: flex-start;
        }

        h1 {
            color: #1976d2;
            margin-bottom: 3px;
            font-size: clamp(1.1rem, 3vw, 2rem);
            font-weight: 600;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(6px, 1vw, 10px);
            flex-wrap: wrap;
        }

        .logo {
            width: clamp(28px, 4vw, 48px);
            height: clamp(28px, 4vw, 48px);
            object-fit: contain;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: clamp(8px, 1.5vw, 12px);
            margin-bottom: clamp(12px, 2vw, 20px);
        }

        .stats {
            display: flex;
            flex-direction: column;
            gap: clamp(10px, 2vw, 15px);
            font-size: clamp(0.9rem, 1.8vw, 1.1rem);
            color: #333;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: clamp(8px, 1.5vw, 12px);
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-label {
            font-size: clamp(0.7rem, 1.3vw, 0.9rem);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .stat-value {
            font-weight: 600;
            font-size: clamp(1rem, 2vw, 1.5rem);
            color: #1976d2;
        }

        button {
            padding: clamp(10px, 1.5vw, 14px) clamp(16px, 2.5vw, 24px);
            font-size: clamp(13px, 1.8vw, 18px);
            border: 1px solid #1976d2;
            border-radius: clamp(4px, 0.8vw, 8px);
            cursor: pointer;
            background: #1976d2;
            color: white;
            transition: all 0.2s;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(25, 118, 210, 0.2);
            touch-action: manipulation;
            min-height: 40px;
        }

        button:hover {
            background: #1565c0;
            border-color: #1565c0;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(25, 118, 210, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        select {
            padding: clamp(10px, 1.5vw, 14px) clamp(12px, 2vw, 16px);
            font-size: clamp(13px, 1.8vw, 18px);
            border: 1px solid #ddd;
            border-radius: clamp(4px, 0.8vw, 8px);
            cursor: pointer;
            background: white;
            color: #333;
            font-weight: 500;
            min-height: 40px;
        }

        select:hover {
            border-color: #1976d2;
        }

        select:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.1);
        }

        .game-board {
            display: grid;
            gap: clamp(4px, 0.8vw, 8px);
            padding: clamp(15px, 2vw, 25px);
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: clamp(6px, 1vw, 12px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 0;
            align-self: flex-start;
            max-height: calc(100vh - 60px);
            max-width: min(90vw, 900px);
            overflow: auto;
            justify-content: center;
            align-content: center;
        }

        .cell {
            aspect-ratio: 1;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            border: 2px solid rgba(255,255,255,0.5);
            touch-action: manipulation;
            width: clamp(30px, 5vw, 55px);
            height: clamp(30px, 5vw, 55px);
        }

        .cell:not(.empty):hover {
            transform: scale(1.1);
            box-shadow: 0 4px 8px rgba(0,0,0,0.25);
        }

        .cell.empty {
            background: transparent !important;
            cursor: default;
            border: none;
            box-shadow: none;
        }

        .cell.highlight {
            animation: pulse 0.5s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(25, 118, 210, 0.8);
        }

        .cell.hint {
            animation: hintPulse 1s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.9);
            border: 3px solid #4caf50;
        }

        @keyframes hintPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(76, 175, 80, 0.9);
            }
            50% { 
                transform: scale(1.2);
                box-shadow: 0 0 30px rgba(76, 175, 80, 1);
            }
        }

        .cell.removing {
            animation: removeCell 0.4s ease-out forwards;
        }

        .bird-image {
            max-width: 75%;
            max-height: 75%;
            object-fit: contain;
            border-radius: 50%;
        }

        .bird-emoji {
            font-size: clamp(1.2rem, 3vw, 2rem);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }

        @keyframes removeCell {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.3);
                opacity: 0.7;
            }
            100% {
                transform: scale(0);
                opacity: 0;
            }
        }

        .victory-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .victory-modal.show {
            display: flex;
            animation: fadeIn 0.3s;
        }

        .modal-content {
            background: white;
            border: 1px solid #e0e0e0;
            padding: clamp(25px, 5vw, 50px);
            border-radius: clamp(6px, 1vw, 12px);
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: scaleIn 0.5s;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #1976d2;
            font-size: clamp(1.5rem, 5vw, 3rem);
            margin-bottom: clamp(15px, 3vw, 25px);
            font-weight: 600;
        }

        .modal-content p {
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            margin-bottom: clamp(8px, 1.5vw, 15px);
            color: #333;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); }
            to { transform: scale(1); }
        }


        .install-prompt p:first-child {
            margin: 0;
            font-weight: 600;
            color: #1976d2;
        }

        .install-prompt p:last-of-type {
            margin: 0;
            font-size: 0.9em;
            color: #666;
        }

        #hintBtn {
            background: #4caf50;
            border-color: #4caf50;
        }

        #hintBtn:hover {
            background: #388e3c;
            border-color: #388e3c;
        }

        #undoBtn {
            background: #ff9800;
            border-color: #ff9800;
        }

        #undoBtn:hover {
            background: #f57c00;
            border-color: #f57c00;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            header {
                width: 100%;
                position: static;
            }

            .game-board {
                width: 100%;
                max-width: 100%;
                max-height: calc(100vh - 100px);
            }

            .cell {
                width: clamp(25px, 8vw, 50px);
                height: clamp(25px, 8vw, 50px);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="install-prompt" id="installPrompt">
            <p>üì± Install this app for the best experience!</p>
            <button id="installButton">Install App</button>
        </div>
        <header>
            <a href="index.html" class="back-link">‚Üê Back to Games</a>
            <h1>
                <img src="https://birdnet.cornell.edu/img/logo-birdnet-circle.png" alt="BirdNET Logo" class="logo">
                Same Game
            </h1>
            
            <div class="game-info-box">
                <strong>How to Play:</strong> Click on groups of 2+ connected birds of the same color. Larger groups score more points!<br>
                <strong>Birds:</strong> Bird colors are weighted by rarity from live BirdNET data‚Äîrarer birds appear less often in the grid.
            </div>
            
            <div class="controls">
                <select id="gridSize">
                    <option value="8">8x8 Grid</option>
                    <option value="10" selected>10x10 Grid</option>
                    <option value="12">12x12 Grid</option>
                    <option value="15">15x15 Grid</option>
                </select>
                
                <select id="colorCount">
                    <option value="3">3 Colors</option>
                    <option value="4">4 Colors</option>
                    <option value="5" selected>5 Colors</option>
                    <option value="6">6 Colors</option>
                </select>
                
                <button id="hintBtn">üí° Get Hint</button>
                <button id="undoBtn">‚Ü∂ Undo</button>
                <button id="newGameBtn">New Game</button>
            </div>
            
            <div class="stats">
                <div class="stat-item">
                    <span class="stat-label">Score</span>
                    <span class="stat-value" id="scoreDisplay">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Moves</span>
                    <span class="stat-value" id="movesDisplay">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Remaining</span>
                    <span class="stat-value" id="remainingDisplay">0</span>
                </div>
            </div>
        </header>

        <div class="game-board" id="gameBoard"></div>
    </div>

    <div class="victory-modal" id="victoryModal">
        <div class="modal-content">
            <h2 id="victoryTitle">üéâ Game Complete! üéâ</h2>
            <p id="victoryMessage"></p>
            <p>Final Score: <strong id="finalScore">0</strong></p>
            <p>Moves: <strong id="finalMoves">0</strong></p>
            <p>Cells Cleared: <strong id="cellsCleared">0</strong></p>
            <button id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <button class="fullscreen-fab" id="fullscreenBtn" title="Toggle Fullscreen">‚õ∂</button>

    <footer>
        <p>Remove connected bird groups to score points! Inspired by <a href="https://birdnet.cornell.edu" target="_blank">BirdNET</a> ‚Ä¢ Data: <a href="https://birdnet.cornell.edu/api2/requeststats" target="_blank">BirdNET API</a> ‚Ä¢ Open source on <a href="https://github.com/Andx667/birdnet-games" target="_blank">GitHub</a></p>
        <p class="footer-line" id="dataSource">Loading bird observations...</p>
    </footer>

    <script src="common.js"></script>
    <script>
        // Fallback bird emojis if API fails
        const FALLBACK_BIRDS = [
            'ü¶Ö', 'ü¶Ü', 'ü¶â', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'üïäÔ∏è', 'ü¶É',
            'üê¶', 'üêß', 'ü¶©', 'üêî', 'üêì', 'ü¶§', 'ü™∂', 'ü¶á'
        ];

        // Bird data will be loaded from BirdNET API - start with fallback
        let BIRDS = FALLBACK_BIRDS.map((emoji, index) => ({ 
            emoji, 
            name: `Bird ${index + 1}`, 
            count: 0,
            useImage: false
        }));
        let BIRD_DATA_SOURCE = 'Loading...';

        const COLORS = [
            '#e91e63', // Pink
            '#2196f3', // Blue
            '#4caf50', // Green
            '#ff9800', // Orange
            '#9c27b0', // Purple
            '#f44336', // Red
        ];

        // Fetch most common bird observations from BirdNET API
        async function fetchBirdData() {
            try {
                const response = await fetch(BIRDNET.apiUrl);
                const data = await response.json();

                const observations = data.observations || [];
                const speciesMap = {};

                observations.forEach(obs => {
                    const species = obs.species;
                    if (species) {
                        const [commonName, scientificName] = species.split(';');
                        if (!speciesMap[commonName]) {
                            speciesMap[commonName] = {
                                name: commonName,
                                scientificName: scientificName,
                                count: 0
                            };
                        }
                        speciesMap[commonName].count++;
                    }
                });

                const speciesData = Object.values(speciesMap)
                    .sort((a, b) => b.count - a.count);

                if (speciesData.length > 0) {
                    const selectedBirds = [];
                    const totalSpecies = speciesData.length;

                    const indices = [
                        0,
                        Math.floor(totalSpecies * 0.1),
                        Math.floor(totalSpecies * 0.2),
                        Math.floor(totalSpecies * 0.3),
                        Math.floor(totalSpecies * 0.4),
                        Math.floor(totalSpecies * 0.5),
                        Math.floor(totalSpecies * 0.6),
                        Math.floor(totalSpecies * 0.7),
                        Math.floor(totalSpecies * 0.8),
                        Math.floor(totalSpecies * 0.85),
                        Math.floor(totalSpecies * 0.9),
                        Math.floor(totalSpecies * 0.93),
                        Math.floor(totalSpecies * 0.95),
                        Math.floor(totalSpecies * 0.97),
                        Math.floor(totalSpecies * 0.98),
                        Math.floor(totalSpecies * 0.99)
                    ];

                    const uniqueIndices = [...new Set(indices)].slice(0, 16);

                    BIRDS = uniqueIndices.map(idx => {
                        const species = speciesData[Math.min(idx, totalSpecies - 1)];
                        return {
                            name: species.name,
                            scientificName: species.scientificName,
                            imageUrl: `https://birdnet.cornell.edu/api2/bird/${encodeURIComponent(species.scientificName)}.webp`,
                            count: species.count,
                            useImage: true
                        };
                    });

                    const totalObservations = observations.length;
                    const uniqueSpecies = speciesData.length;
                    BIRD_DATA_SOURCE = formatBirdnetLiveData({ totalObservations, uniqueSpecies, hours: BIRDNET_DATA_WINDOW_HOURS });
                } else {
                    useFallbackBirds();
                }
            } catch (error) {
                console.error('Failed to fetch bird data:', error);
                useFallbackBirds();
            }
        }

        function useFallbackBirds() {
            BIRD_DATA_SOURCE = 'Using fallback data';
        }

        function getBirdEmoji(speciesName) {
            const name = speciesName.toLowerCase();
            if (name.includes('owl')) return 'ü¶â';
            if (name.includes('duck')) return 'ü¶Ü';
            if (name.includes('eagle') || name.includes('hawk')) return 'ü¶Ö';
            if (name.includes('swan')) return 'ü¶¢';
            if (name.includes('dove') || name.includes('pigeon')) return 'üïäÔ∏è';
            if (name.includes('parrot') || name.includes('macaw')) return 'ü¶ú';
            if (name.includes('flamingo')) return 'ü¶©';
            if (name.includes('penguin')) return 'üêß';
            if (name.includes('chicken') || name.includes('hen')) return 'üêî';
            if (name.includes('rooster')) return 'üêì';
            if (name.includes('turkey')) return 'ü¶É';
            if (name.includes('peacock')) return 'ü¶ö';
            if (name.includes('dodo')) return 'ü¶§';
            if (name.includes('crow') || name.includes('raven') || name.includes('blackbird')) return 'üê¶‚Äç‚¨õ';
            return 'üê¶';
        }

        function getWeightedBirdIndex(colorCount) {
            const availableBirds = BIRDS.slice(0, colorCount);

            const hasRealCounts = availableBirds.some(b => b.count > 0);
            if (!hasRealCounts) {
                return Math.floor(Math.random() * colorCount);
            }

            const weights = availableBirds.map(bird => {
                const logWeight = Math.log(bird.count + 1) + 1;
                return logWeight;
            });

            const totalWeight = weights.reduce((sum, w) => sum + w, 0);

            let random = Math.random() * totalWeight;
            for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return i;
                }
            }

            return colorCount - 1;
        }

        // Game logic
        class SameGame {
            constructor() {
                this.gameBoard = document.getElementById('gameBoard');
                this.scoreDisplay = document.getElementById('scoreDisplay');
                this.movesDisplay = document.getElementById('movesDisplay');
                this.remainingDisplay = document.getElementById('remainingDisplay');
                this.victoryModal = document.getElementById('victoryModal');
                this.gridSizeSelect = document.getElementById('gridSize');
                this.colorCountSelect = document.getElementById('colorCount');
                
                this.gridSize = parseInt(this.gridSizeSelect.value);
                this.colorCount = parseInt(this.colorCountSelect.value);
                this.grid = [];
                this.score = 0;
                this.moves = 0;
                this.totalCellsCleared = 0;
                
                this.setupEventListeners();
                this.initGame();
            }

            setupEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.initGame());
                document.getElementById('hintBtn').addEventListener('click', () => this.showHint());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('playAgainBtn').addEventListener('click', () => {
                    this.victoryModal.classList.remove('show');
                    this.initGame();
                });
                
                this.gridSizeSelect.addEventListener('change', () => {
                    this.gridSize = parseInt(this.gridSizeSelect.value);
                    this.initGame();
                });
                
                this.colorCountSelect.addEventListener('change', () => {
                    this.colorCount = parseInt(this.colorCountSelect.value);
                    this.initGame();
                });
            }

            initGame() {
                this.score = 0;
                this.moves = 0;
                this.totalCellsCleared = 0;
                this.grid = [];
                this.clearHint();
                this.stateHistory = []; // Store previous states for undo
                this.updateUndoButton();
                
                // Create grid with weighted bird distribution
                for (let row = 0; row < this.gridSize; row++) {
                    this.grid[row] = [];
                    for (let col = 0; col < this.gridSize; col++) {
                        // Use weighted selection based on bird observation counts
                        const colorIndex = getWeightedBirdIndex(this.colorCount);
                        const birdIndex = colorIndex % BIRDS.length;
                        this.grid[row][col] = {
                            color: COLORS[colorIndex],
                            colorIndex: colorIndex,
                            bird: BIRDS[birdIndex] || FALLBACK_BIRDS[birdIndex],
                            isEmpty: false
                        };
                    }
                }
                
                this.renderBoard();
                this.updateDisplay();
            }

            saveState() {
                // Deep copy current state
                const state = {
                    grid: this.grid.map(row => row.map(cell => ({...cell}))),
                    score: this.score,
                    moves: this.moves,
                    totalCellsCleared: this.totalCellsCleared
                };
                this.stateHistory.push(state);
                
                // Limit history to last 20 moves to save memory
                if (this.stateHistory.length > 20) {
                    this.stateHistory.shift();
                }
                
                this.updateUndoButton();
            }

            undoMove() {
                if (this.stateHistory.length === 0) {
                    return; // Nothing to undo
                }
                
                // Restore previous state
                const previousState = this.stateHistory.pop();
                this.grid = previousState.grid.map(row => row.map(cell => ({...cell})));
                this.score = previousState.score;
                this.moves = previousState.moves;
                this.totalCellsCleared = previousState.totalCellsCleared;
                
                this.clearHint();
                this.renderBoard();
                this.updateDisplay();
                this.updateUndoButton();
            }

            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.disabled = this.stateHistory.length === 0;
                    undoBtn.style.opacity = this.stateHistory.length === 0 ? '0.5' : '1';
                    undoBtn.style.cursor = this.stateHistory.length === 0 ? 'not-allowed' : 'pointer';
                }
            }

            renderBoard() {
                this.gameBoard.innerHTML = '';
                this.gameBoard.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        const cellData = this.grid[row][col];
                        
                        if (cellData.isEmpty) {
                            cell.classList.add('empty');
                        } else {
                            cell.style.background = cellData.color;
                            
                            if (cellData.bird.useImage) {
                                const img = document.createElement('img');
                                img.className = 'bird-image';
                                img.src = cellData.bird.imageUrl;
                                img.alt = cellData.bird.name;
                                img.title = cellData.bird.name;
                                cell.appendChild(img);
                            } else {
                                const emoji = document.createElement('div');
                                emoji.className = 'bird-emoji';
                                emoji.textContent = cellData.bird.emoji || getBirdEmoji(cellData.bird.name);
                                emoji.title = cellData.bird.name;
                                cell.appendChild(emoji);
                            }
                            
                            cell.addEventListener('click', () => this.handleCellClick(row, col));
                            cell.addEventListener('mouseenter', () => this.highlightGroup(row, col, true));
                            cell.addEventListener('mouseleave', () => this.highlightGroup(row, col, false));
                        }
                        
                        this.gameBoard.appendChild(cell);
                    }
                }
            }

            handleCellClick(row, col) {
                const cellData = this.grid[row][col];
                if (cellData.isEmpty) return;
                
                const group = this.findConnectedGroup(row, col, cellData.colorIndex);
                
                // Need at least 2 connected cells
                if (group.length < 2) return;
                
                // Save current state for undo
                this.saveState();
                
                // Clear any hint and highlight first
                this.clearHint();
                this.highlightGroup(row, col, false);
                
                // Remove the group with animation
                this.removeGroup(group);
                
                // Update score based on group size (n * (n-1))
                const points = group.length * (group.length - 1);
                this.score += points;
                this.moves++;
                this.totalCellsCleared += group.length;
                
                // Apply gravity after a short delay
                setTimeout(() => {
                    this.applyGravity();
                    this.renderBoard();
                    this.updateDisplay();
                    this.updateUndoButton();
                    
                    // Check for game over
                    if (this.isGameOver()) {
                        this.handleGameOver();
                    }
                }, 400);
            }

            findConnectedGroup(row, col, colorIndex) {
                const visited = new Set();
                const group = [];
                const stack = [[row, col]];
                
                while (stack.length > 0) {
                    const [r, c] = stack.pop();
                    const key = `${r},${c}`;
                    
                    if (visited.has(key)) continue;
                    if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) continue;
                    if (this.grid[r][c].isEmpty) continue;
                    if (this.grid[r][c].colorIndex !== colorIndex) continue;
                    
                    visited.add(key);
                    group.push([r, c]);
                    
                    // Check orthogonal neighbors
                    stack.push([r - 1, c]); // Up
                    stack.push([r + 1, c]); // Down
                    stack.push([r, c - 1]); // Left
                    stack.push([r, c + 1]); // Right
                }
                
                return group;
            }

            // Deep copy grid for simulation
            copyGrid() {
                return this.grid.map(row => row.map(cell => ({...cell})));
            }

            // Find all valid moves (groups of 2+)
            findAllMoves(grid = this.grid) {
                const moves = [];
                const checked = new Set();
                
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const key = `${row},${col}`;
                        if (checked.has(key) || grid[row][col].isEmpty) continue;
                        
                        const group = this.findConnectedGroupInGrid(grid, row, col, grid[row][col].colorIndex);
                        if (group.length >= 2) {
                            moves.push({ row, col, group, score: group.length * (group.length - 1) });
                            // Mark all cells in this group as checked
                            group.forEach(([r, c]) => checked.add(`${r},${c}`));
                        }
                    }
                }
                
                return moves;
            }

            // Find connected group in a specific grid (for simulation)
            findConnectedGroupInGrid(grid, row, col, colorIndex) {
                const visited = new Set();
                const group = [];
                const stack = [[row, col]];
                
                while (stack.length > 0) {
                    const [r, c] = stack.pop();
                    const key = `${r},${c}`;
                    
                    if (visited.has(key)) continue;
                    if (r < 0 || r >= this.gridSize || c < 0 || c >= this.gridSize) continue;
                    if (grid[r][c].isEmpty) continue;
                    if (grid[r][c].colorIndex !== colorIndex) continue;
                    
                    visited.add(key);
                    group.push([r, c]);
                    
                    stack.push([r - 1, c]);
                    stack.push([r + 1, c]);
                    stack.push([r, c - 1]);
                    stack.push([r, c + 1]);
                }
                
                return group;
            }

            // Simulate a move on a grid copy
            simulateMove(grid, move) {
                const newGrid = grid.map(row => row.map(cell => ({...cell})));
                
                // Remove the group
                move.group.forEach(([r, c]) => {
                    newGrid[r][c] = { isEmpty: true };
                });
                
                // Apply gravity
                this.applyGravityToGrid(newGrid);
                
                return newGrid;
            }

            // Apply gravity to a grid copy
            applyGravityToGrid(grid) {
                // Make cells fall down
                for (let col = 0; col < this.gridSize; col++) {
                    let writePos = this.gridSize - 1;
                    for (let row = this.gridSize - 1; row >= 0; row--) {
                        if (!grid[row][col].isEmpty) {
                            if (writePos !== row) {
                                grid[writePos][col] = grid[row][col];
                                grid[row][col] = { isEmpty: true };
                            }
                            writePos--;
                        }
                    }
                }
                
                // Shift columns to the left
                let writeCol = 0;
                for (let col = 0; col < this.gridSize; col++) {
                    const isEmpty = grid.every(row => row[col].isEmpty);
                    
                    if (!isEmpty) {
                        if (writeCol !== col) {
                            for (let row = 0; row < this.gridSize; row++) {
                                grid[row][writeCol] = grid[row][col];
                                grid[row][col] = { isEmpty: true };
                            }
                        }
                        writeCol++;
                    }
                }
            }

            // Evaluate board state (lower remaining cells = better)
            evaluateBoard(grid) {
                let remaining = 0;
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!grid[row][col].isEmpty) remaining++;
                    }
                }
                return remaining;
            }

            // Recursive lookahead with limited depth
            lookahead(grid, depth, maxDepth = 3) {
                if (depth >= maxDepth) {
                    return this.evaluateBoard(grid);
                }
                
                const moves = this.findAllMoves(grid);
                if (moves.length === 0) {
                    return this.evaluateBoard(grid);
                }
                
                let bestScore = Infinity;
                for (const move of moves) {
                    const newGrid = this.simulateMove(grid, move);
                    const score = this.lookahead(newGrid, depth + 1, maxDepth);
                    bestScore = Math.min(bestScore, score);
                }
                
                return bestScore;
            }

            // Show hint - find and highlight best move
            showHint() {
                // Clear any existing hints
                this.clearHint();
                
                const moves = this.findAllMoves();
                if (moves.length === 0) {
                    alert('No moves available!');
                    return;
                }
                
                // Evaluate each move with lookahead
                let bestMove = null;
                let bestEvaluation = Infinity;
                
                for (const move of moves) {
                    const newGrid = this.simulateMove(this.grid, move);
                    // Score = immediate points (negative because we want to maximize) + future potential
                    const futureScore = this.lookahead(newGrid, 1, 3);
                    const immediatePoints = move.score;
                    // Combine: prefer high immediate score and low future remaining cells
                    const evaluation = futureScore - (immediatePoints * 0.5);
                    
                    if (evaluation < bestEvaluation) {
                        bestEvaluation = evaluation;
                        bestMove = move;
                    }
                }
                
                if (bestMove) {
                    // Highlight the suggested move
                    bestMove.group.forEach(([r, c]) => {
                        const cell = this.gameBoard.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                        if (cell) {
                            cell.classList.add('hint');
                        }
                    });
                    
                    // Store hint for clearing later
                    this.currentHint = bestMove;
                    
                    // Auto-clear hint after 5 seconds
                    if (this.hintTimeout) clearTimeout(this.hintTimeout);
                    this.hintTimeout = setTimeout(() => this.clearHint(), 5000);
                }
            }

            clearHint() {
                document.querySelectorAll('.cell.hint').forEach(cell => {
                    cell.classList.remove('hint');
                });
                this.currentHint = null;
                if (this.hintTimeout) {
                    clearTimeout(this.hintTimeout);
                    this.hintTimeout = null;
                }
            }

            highlightGroup(row, col, highlight) {
                const cellData = this.grid[row][col];
                if (cellData.isEmpty) return;
                
                const group = this.findConnectedGroup(row, col, cellData.colorIndex);
                if (group.length < 2) return;
                
                group.forEach(([r, c]) => {
                    const cell = this.gameBoard.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        if (highlight) {
                            cell.classList.add('highlight');
                        } else {
                            cell.classList.remove('highlight');
                        }
                    }
                });
            }

            removeGroup(group) {
                group.forEach(([r, c]) => {
                    const cell = this.gameBoard.querySelector(`[data-row="${r}"][data-col="${c}"]`);
                    if (cell) {
                        cell.classList.add('removing');
                    }
                    this.grid[r][c].isEmpty = true;
                });
            }

            applyGravity() {
                // First, make cells fall down
                for (let col = 0; col < this.gridSize; col++) {
                    let writePos = this.gridSize - 1;
                    for (let row = this.gridSize - 1; row >= 0; row--) {
                        if (!this.grid[row][col].isEmpty) {
                            if (writePos !== row) {
                                this.grid[writePos][col] = this.grid[row][col];
                                this.grid[row][col] = { isEmpty: true };
                            }
                            writePos--;
                        }
                    }
                }
                
                // Then, shift columns to the left
                let writeCol = 0;
                for (let col = 0; col < this.gridSize; col++) {
                    // Check if column is empty
                    const isEmpty = this.grid.every(row => row[col].isEmpty);
                    
                    if (!isEmpty) {
                        if (writeCol !== col) {
                            for (let row = 0; row < this.gridSize; row++) {
                                this.grid[row][writeCol] = this.grid[row][col];
                                this.grid[row][col] = { isEmpty: true };
                            }
                        }
                        writeCol++;
                    }
                }
            }

            isGameOver() {
                // Check if there are any valid moves left (groups of 2 or more)
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!this.grid[row][col].isEmpty) {
                            const group = this.findConnectedGroup(row, col, this.grid[row][col].colorIndex);
                            if (group.length >= 2) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }

            updateDisplay() {
                this.scoreDisplay.textContent = this.score;
                this.movesDisplay.textContent = this.moves;
                
                // Count remaining cells
                let remaining = 0;
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!this.grid[row][col].isEmpty) {
                            remaining++;
                        }
                    }
                }
                this.remainingDisplay.textContent = remaining;
            }

            handleGameOver() {
                // Count remaining cells
                let remaining = 0;
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        if (!this.grid[row][col].isEmpty) {
                            remaining++;
                        }
                    }
                }
                
                // Bonus for clearing all cells
                if (remaining === 0) {
                    this.score += 1000;
                    document.getElementById('victoryTitle').textContent = 'üèÜ Perfect Clear! üèÜ';
                    document.getElementById('victoryMessage').textContent = 'You cleared the entire board! +1000 bonus points!';
                } else {
                    document.getElementById('victoryTitle').textContent = 'üéâ Game Complete! üéâ';
                    document.getElementById('victoryMessage').textContent = `${remaining} cells remaining. Try to clear them all!`;
                }
                
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('finalMoves').textContent = this.moves;
                document.getElementById('cellsCleared').textContent = this.totalCellsCleared;
                
                setTimeout(() => {
                    this.victoryModal.classList.add('show');
                }, 500);
            }
        }

        initCommon({
            name: 'BirdNET Same Game',
            shortName: 'Same Game',
            description: 'Remove connected bird groups in this classic puzzle game',
            startUrl: './samegame.html',
            cacheName: 'bird-samegame-v1',
            logLabel: 'BirdNET Same Game'
        });

        // Initialize game variable
        let game;

        // Fetch bird data first, then initialize game
        fetchBirdData().then(() => {
            setFooterDataSourceText(BIRD_DATA_SOURCE);
            game = new SameGame();
        }).catch(() => {
            // If API fails, still initialize with fallback
            setFooterDataSourceText(BIRD_DATA_SOURCE);
            game = new SameGame();
        });
    </script>
</body>
</html>