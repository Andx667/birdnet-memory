<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1976d2">
    <meta name="description" content="BirdNET Connect Four - Four in a row with bird species">
    <title>BirdNET Connect Four</title>
    
    <link rel="manifest" href="#" id="manifest-placeholder">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            min-height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: clamp(10px, 2vw, 20px);
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: min(1400px, 95vw);
            width: 100%;
            display: flex;
            gap: clamp(15px, 2vw, 25px);
            align-items: flex-start;
            flex-wrap: wrap;
        }

        header {
            background: white;
            padding: clamp(15px, 2vw, 25px);
            border-radius: clamp(8px, 1.5vw, 12px);
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
            flex: 0 0 auto;
            width: clamp(220px, 28vw, 320px);
            position: sticky;
            top: 20px;
            align-self: flex-start;
        }

        h1 {
            color: #1976d2;
            margin-bottom: 3px;
            font-size: clamp(1.1rem, 3vw, 2rem);
            font-weight: 600;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(6px, 1vw, 10px);
            flex-wrap: wrap;
        }

        .logo {
            width: clamp(28px, 4vw, 48px);
            height: clamp(28px, 4vw, 48px);
            object-fit: contain;
        }

        .subtitle {
            color: #666;
            font-size: clamp(0.85rem, 2vw, 1rem);
            margin-bottom: 15px;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .game-status {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 15px;
        }

        .status-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #1976d2;
        }

        .player-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        .player-piece {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #333;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            border: 1px solid #1976d2;
            border-radius: 8px;
            cursor: pointer;
            background: #1976d2;
            color: white;
            font-weight: 600;
            transition: all 0.2s;
            touch-action: manipulation;
        }

        button:hover {
            background: #1565c0;
            transform: translateY(-1px);
        }

        .grid-wrapper {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .grid-container {
            background: white;
            padding: clamp(15px, 2vw, 25px);
            border-radius: clamp(8px, 1.5vw, 12px);
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .game-board {
            background: #1976d2;
            border-radius: 12px;
            padding: clamp(10px, 2vw, 20px);
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: clamp(8px, 1.5vw, 12px);
            max-width: min(700px, 100%);
            margin: 0 auto;
            width: 100%;
        }

        .cell {
            aspect-ratio: 1;
            background: white;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .cell:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        .cell.disabled {
            cursor: not-allowed;
        }

        .cell.disabled:hover {
            transform: none;
        }

        .piece {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            animation: drop 0.5s ease-out;
        }

        .piece img {
            width: 70%;
            height: 70%;
            object-fit: contain;
            border-radius: 50%;
        }

        .piece.winning {
            animation: pulse 0.6s ease-in-out infinite;
        }

        @keyframes drop {
            from {
                transform: translateY(-300%);
            }
            to {
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .game-message {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .game-message.show {
            display: flex;
        }

        .message-content {
            background: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 90%;
        }

        .message-content h2 {
            color: #1976d2;
            font-size: 2rem;
            margin-bottom: 20px;
        }

        .message-content button {
            margin-top: 20px;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            color: #666;
            font-size: clamp(1rem, 2vw, 1.2rem);
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #1976d2;
            text-decoration: none;
            font-weight: 500;
            font-size: clamp(0.85rem, 1.8vw, 1rem);
        }

        .back-link:hover {
            text-decoration: underline;
        }

        footer {
            color: #666;
            text-align: center;
            padding: clamp(15px, 2vw, 25px);
            font-size: clamp(0.75rem, 1.8vw, 1.1rem);
            line-height: 1.6;
        }

        footer a {
            color: #1976d2;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .footer-line {
            margin-top: 5px;
        }

        .footer-status {
            font-size: 0.85em;
        }

        .footer-source {
            font-size: 0.8em;
        }

        .install-prompt {
            background: #e3f2fd;
            border: 1px solid #1976d2;
            color: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
            flex: 0 0 100%;
        }

        .install-prompt.show {
            display: block;
        }

        .install-prompt button {
            margin-top: 10px;
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        .fullscreen-fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            background: #1976d2;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .fullscreen-fab:hover {
            background: #1565c0;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }

        .fullscreen-fab:active {
            transform: scale(0.95);
        }

        /* Responsive layout */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            header {
                width: 100%;
                position: static;
            }
            
            .grid-wrapper {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .game-board {
                gap: 6px;
                padding: 12px;
            }
        }

        .game-info-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.85rem;
            color: #555;
            line-height: 1.4;
        }

        .hidden {
            display: none !important;
        }

        #undoBtn {
            background: #ff9800;
            border-color: #ff9800;
        }

        #undoBtn:hover {
            background: #f57c00;
        }

        .winner-image {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            margin: 20px auto;
            display: block;
            object-fit: contain;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="install-prompt" id="installPrompt">
            <p>üì± Install this app for the best experience!</p>
            <button id="installButton">Install App</button>
        </div>

        <header>
            <a href="index.html" class="back-link">‚Üê Back to Games</a>
            <h1>
                <img src="https://birdnet.cornell.edu/img/logo-birdnet-circle.png" alt="BirdNET Logo" class="logo">
                BirdNET Connect Four
            </h1>
            <div class="subtitle">Four in a row wins!</div>
            
            <div class="game-info-box">
                <strong>How to Play:</strong> Drop birds into columns to connect four of your color vertically, horizontally, or diagonally.<br>
                <strong>Birds:</strong> Each game features a random common vs. rare bird from live BirdNET data. Colors match the birds' names!
            </div>
            
            <div class="game-status">
                <div class="status-text" id="statusText">Loading birds...</div>
                <div class="player-indicator hidden" id="playerIndicator">
                    <div class="player-piece" id="currentPiece"></div>
                </div>
            </div>

            <div class="controls">
                <button id="undoBtn">‚Ü∂ Undo</button>
                <button id="newGameBtn">New Game</button>
            </div>
        </header>

        <div class="grid-wrapper">
            <div class="grid-container" id="gridContainer">
                <div id="loading" class="loading">Loading bird data from BirdNET...</div>
                <div id="gameBoard" class="game-board hidden"></div>
            </div>
        </div>
    </div>

    <div class="game-message" id="gameMessage">
        <div class="message-content">
            <h2 id="messageText">Game Over!</h2>
            <div id="winnerDisplay"></div>
            <button onclick="game.restart()">Play Again</button>
        </div>
    </div>

    <button class="fullscreen-fab" id="fullscreenBtn" title="Toggle Fullscreen">‚õ∂</button>

    <footer>
        <p>Connect four birds in a row! Inspired by <a href="https://birdnet.cornell.edu" target="_blank">BirdNET</a></p>
        <p class="footer-line footer-status" id="dataSource">Loading bird observations...</p>
        <p class="footer-line footer-source">Data source: <a href="https://birdnet.cornell.edu/api2/requeststats" target="_blank">BirdNET API</a></p>
        <p class="footer-line">This project is open source on <a href="https://github.com/Andx667/birdnet-games" target="_blank">GitHub</a></p>
    </footer>

    <script>
        const BIRDNET = {
            apiUrl: 'https://birdnet.cornell.edu/api2/requeststats',
            iconUrl: 'https://birdnet.cornell.edu/img/logo-birdnet-circle.png',
            themeColor: '#1976d2'
        };

        const BIRDNET_DATA_WINDOW_HOURS = 24;

        function setFooterDataSourceText(text) {
            const sourceElement = document.getElementById('dataSource');
            if (sourceElement) {
                sourceElement.textContent = text;
            }
        }

        function formatBirdnetLiveData({ totalObservations, uniqueSpecies, hours = BIRDNET_DATA_WINDOW_HOURS }) {
            const safeHours = Number.isFinite(hours) && hours > 0 ? Math.round(hours) : BIRDNET_DATA_WINDOW_HOURS;
            const obsText = Number.isFinite(totalObservations) ? totalObservations.toLocaleString() : '0';
            const speciesText = Number.isFinite(uniqueSpecies) ? uniqueSpecies.toLocaleString() : '0';
            return `Live data from BirdNET (${obsText} observations, ${speciesText} species in last ${safeHours}h)`;
        }

        let BIRDS = [];
        let BIRD_DATA_SOURCE = 'Loading...';

        async function fetchBirdData() {
            try {
                const response = await fetch(BIRDNET.apiUrl);
                const data = await response.json();
                
                const observations = data.observations || [];
                const speciesMap = {};
                
                observations.forEach(obs => {
                    const species = obs.species;
                    if (species) {
                        const [commonName, scientificName] = species.split(';');
                        if (!speciesMap[commonName]) {
                            speciesMap[commonName] = {
                                name: commonName,
                                scientificName: scientificName,
                                count: 0
                            };
                        }
                        speciesMap[commonName].count++;
                    }
                });
                
                const speciesData = Object.values(speciesMap)
                    .sort((a, b) => b.count - a.count);
                
                // Select one common bird (from top 10) and one rare bird (from bottom 10)
                const poolSize = Math.min(10, speciesData.length);
                
                if (speciesData.length >= 2) {
                    // Get pools
                    const commonPool = speciesData.slice(0, poolSize); // Most common
                    const rarePool = speciesData.slice(-poolSize); // Least common
                    
                    // Randomly select one from each pool
                    const commonBird = commonPool[Math.floor(Math.random() * commonPool.length)];
                    const rareBird = rarePool[Math.floor(Math.random() * rarePool.length)];
                    
                    // Player 1 gets common bird, Player 2 gets rare bird
                    BIRDS = [commonBird, rareBird].map(species => ({
                        name: species.name,
                        scientificName: species.scientificName,
                        imageUrl: `https://birdnet.cornell.edu/api2/bird/${encodeURIComponent(species.scientificName)}.webp`,
                        count: species.count
                    }));
                    
                    const totalObservations = observations.length;
                    const uniqueSpecies = Object.keys(speciesMap).length;
                    BIRD_DATA_SOURCE = formatBirdnetLiveData({ totalObservations, uniqueSpecies, hours: BIRDNET_DATA_WINDOW_HOURS });
                    setFooterDataSourceText(BIRD_DATA_SOURCE);
                }
                
                return true;
            } catch (error) {
                console.error('Failed to fetch bird data:', error);
                setFooterDataSourceText('Failed to load bird data');
                return false;
            }
        }

        // Extract color from bird name or make educated guess
        function getBirdColor(birdName) {
            const name = birdName.toLowerCase();
            
            // Color word mapping
            const colorMap = {
                'red': '#d32f2f',
                'blue': '#0d47a1',  // Darker blue, distinct from grid (#1976d2)
                'yellow': '#fbc02d',
                'green': '#388e3c',
                'emerald': '#00897b',  // Emerald green
                'olive': '#689f38',
                'lime': '#9ccc65',
                'orange': '#f57c00',
                'purple': '#7b1fa2',
                'violet': '#7b1fa2',
                'pink': '#c2185b',
                'brown': '#5d4037',
                'gray': '#616161',
                'grey': '#616161',
                'black': '#212121',
                'coal': '#424242',  // Dark grey
                'white': '#eeeeee',
                'golden': '#fbc02d',
                'gold': '#fbc02d',
                'scarlet': '#d32f2f',
                'crimson': '#c62828',
                'indigo': '#283593',  // Darker indigo, distinct from grid
                'turquoise': '#00897b',
                'teal': '#00796b',
                'rust': '#bf360c',
                'copper': '#d84315',
                'silver': '#bdbdbd',
                'rose': '#e91e63'
            };
            
            // Check for color words in name
            for (const [colorWord, colorHex] of Object.entries(colorMap)) {
                if (name.includes(colorWord)) {
                    return colorHex;
                }
            }
            
            // Educated guesses based on bird types
            if (name.includes('cardinal')) return '#d32f2f';
            if (name.includes('robin')) return '#d84315';
            if (name.includes('bluebird')) return '#0d47a1';  // Darker blue
            if (name.includes('jay')) return '#1565c0';  // Darker blue
            if (name.includes('goldfinch') || name.includes('canary')) return '#fbc02d';
            if (name.includes('oriole')) return '#ff6f00';
            if (name.includes('tanager')) return '#c62828';
            if (name.includes('bunting')) return '#0d47a1';  // Darker blue
            if (name.includes('warbler')) return '#fdd835';
            if (name.includes('sparrow') || name.includes('wren')) return '#8d6e63';
            if (name.includes('crow') || name.includes('raven') || name.includes('grackle')) return '#212121';
            if (name.includes('dove') || name.includes('pigeon')) return '#9e9e9e';
            if (name.includes('hawk') || name.includes('eagle') || name.includes('falcon')) return '#5d4037';
            if (name.includes('owl')) return '#6d4c41';
            if (name.includes('heron') || name.includes('egret')) return '#eeeeee';
            if (name.includes('duck')) return '#00897b';
            if (name.includes('goose')) return '#9e9e9e';
            if (name.includes('swan')) return '#fafafa';
            if (name.includes('finch')) return '#f57c00';
            if (name.includes('hummingbird')) return '#00897b';
            if (name.includes('woodpecker')) return '#d32f2f';
            if (name.includes('chickadee') || name.includes('titmouse')) return '#757575';
            if (name.includes('nuthatch')) return '#546e7a';
            
            // Default fallback colors
            return '#0d47a1';  // Darker blue as default, distinct from grid
        }

        // Calculate color contrast ratio
        function getContrastRatio(color1, color2) {
            const getLuminance = (hex) => {
                const rgb = parseInt(hex.slice(1), 16);
                const r = ((rgb >> 16) & 0xff) / 255;
                const g = ((rgb >> 8) & 0xff) / 255;
                const b = (rgb & 0xff) / 255;
                
                const [rs, gs, bs] = [r, g, b].map(c => {
                    return c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4);
                });
                
                return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
            };
            
            const lum1 = getLuminance(color1);
            const lum2 = getLuminance(color2);
            const lighter = Math.max(lum1, lum2);
            const darker = Math.min(lum1, lum2);
            
            return (lighter + 0.05) / (darker + 0.05);
        }

        // Adjust color for better contrast
        function ensureContrast(color1, color2, minContrast = 4.5) {
            const contrast = getContrastRatio(color1, color2);
            
            if (contrast >= minContrast) {
                return color2;
            }
            
            // If contrast is too low, try to adjust brightness
            const adjustBrightness = (hex, amount) => {
                const rgb = parseInt(hex.slice(1), 16);
                let r = (rgb >> 16) & 0xff;
                let g = (rgb >> 8) & 0xff;
                let b = rgb & 0xff;
                
                r = Math.max(0, Math.min(255, r + amount));
                g = Math.max(0, Math.min(255, g + amount));
                b = Math.max(0, Math.min(255, b + amount));
                
                return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
            };
            
            // Normalize colors for comparison (ensure lowercase and 6-digit format)
            const normalizeColor = (hex) => {
                if (hex.length === 4) {
                    // Convert #abc to #aabbcc
                    return '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                return hex.toLowerCase();
            };
            
            const normalized1 = normalizeColor(color1);
            const normalized2 = normalizeColor(color2);
            
            // Try darkening first
            let adjusted = adjustBrightness(color2, -80);
            if (getContrastRatio(color1, adjusted) >= minContrast) {
                return adjusted;
            }
            
            // Try lightening
            adjusted = adjustBrightness(color2, 80);
            if (getContrastRatio(color1, adjusted) >= minContrast) {
                return adjusted;
            }
            
            // Last resort: use complementary high-contrast colors
            const alternates = ['#d32f2f', '#0d47a1', '#388e3c', '#f57c00', '#7b1fa2', '#00897b'];
            for (const alt of alternates) {
                // Skip if this alternate is the same as color1
                if (normalizeColor(alt) === normalized1) {
                    continue;
                }
                if (getContrastRatio(color1, alt) >= minContrast) {
                    return alt;
                }
            }
            
            // Absolute fallback: return a color that's definitely different from color1
            return normalized1 === '#d32f2f' ? '#0d47a1' : '#d32f2f';
        }

        class ConnectFour {
            constructor() {
                this.rows = 6;
                this.cols = 7;
                this.board = [];
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winningCells = [];
                this.stateHistory = []; // Store previous states for undo
                
                this.gameBoard = document.getElementById('gameBoard');
                this.loading = document.getElementById('loading');
                this.statusText = document.getElementById('statusText');
                this.playerIndicator = document.getElementById('playerIndicator');
                this.currentPiece = document.getElementById('currentPiece');
                this.gameMessage = document.getElementById('gameMessage');
                this.messageText = document.getElementById('messageText');
                this.winnerDisplay = document.getElementById('winnerDisplay');
                
                document.getElementById('newGameBtn').addEventListener('click', () => this.restart());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
            }

            async init() {
                const success = await fetchBirdData();
                if (success && BIRDS.length >= 2) {
                    // Set player colors based on bird names
                    this.player1Color = getBirdColor(BIRDS[0].name);
                    this.player2Color = getBirdColor(BIRDS[1].name);
                    
                    // Ensure sufficient contrast between colors
                    this.player2Color = ensureContrast(this.player1Color, this.player2Color);
                    
                    // Apply colors to CSS
                    this.applyPlayerColors();
                    
                    this.loading.classList.add('hidden');
                    this.gameBoard.classList.remove('hidden');
                    this.createBoard();
                    this.updateStatus();
                } else {
                    this.loading.textContent = 'Failed to load bird data. Please refresh.';
                }
            }

            applyPlayerColors() {
                // Create or update dynamic style element
                let styleEl = document.getElementById('player-colors');
                if (!styleEl) {
                    styleEl = document.createElement('style');
                    styleEl.id = 'player-colors';
                    document.head.appendChild(styleEl);
                }
                
                styleEl.textContent = `
                    .player1-piece {
                        background: ${this.player1Color} !important;
                    }
                    .player2-piece {
                        background: ${this.player2Color} !important;
                    }
                    .piece.player1 {
                        background: ${this.player1Color} !important;
                    }
                    .piece.player2 {
                        background: ${this.player2Color} !important;
                    }
                `;
            }

            createBoard() {
                this.board = Array(this.rows).fill(null).map(() => Array(this.cols).fill(0));
                this.gameBoard.innerHTML = '';
                this.stateHistory = []; // Clear history on new board
                this.updateUndoButton();
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        cell.addEventListener('click', () => this.handleCellClick(col));
                        this.gameBoard.appendChild(cell);
                    }
                }
            }

            handleCellClick(col) {
                if (this.gameOver) return;
                
                const row = this.getLowestEmptyRow(col);
                if (row === -1) return;
                
                // Save current state for undo
                this.saveState();
                
                this.board[row][col] = this.currentPlayer;
                this.renderPiece(row, col, this.currentPlayer);
                
                if (this.checkWin(row, col)) {
                    this.gameOver = true;
                    this.highlightWinningCells();
                    setTimeout(() => this.showWinner(), 500);
                } else if (this.isBoardFull()) {
                    this.gameOver = true;
                    setTimeout(() => this.showDraw(), 500);
                } else {
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    this.updateStatus();
                }
            }

            getLowestEmptyRow(col) {
                for (let row = this.rows - 1; row >= 0; row--) {
                    if (this.board[row][col] === 0) {
                        return row;
                    }
                }
                return -1;
            }

            renderPiece(row, col, player) {
                const cellIndex = row * this.cols + col;
                const cell = this.gameBoard.children[cellIndex];
                
                const piece = document.createElement('div');
                piece.className = `piece player${player}`;
                
                if (BIRDS.length >= 2) {
                    // BIRDS array contains the two rarest birds [0, 1]
                    const bird = BIRDS[player - 1];
                    const img = document.createElement('img');
                    img.src = bird.imageUrl;
                    img.alt = bird.name;
                    img.onerror = () => {
                        img.classList.add('hidden');
                    };
                    piece.appendChild(img);
                }
                
                cell.appendChild(piece);
            }

            checkWin(row, col) {
                const directions = [
                    { dr: 0, dc: 1 },   // horizontal
                    { dr: 1, dc: 0 },   // vertical
                    { dr: 1, dc: 1 },   // diagonal \
                    { dr: 1, dc: -1 }   // diagonal /
                ];
                
                for (const { dr, dc } of directions) {
                    const cells = this.getLineOfFour(row, col, dr, dc);
                    if (cells.length >= 4) {
                        this.winningCells = cells;
                        return true;
                    }
                }
                
                return false;
            }

            getLineOfFour(row, col, dr, dc) {
                const player = this.board[row][col];
                const cells = [[row, col]];
                
                // Check forward direction
                let r = row + dr;
                let c = col + dc;
                while (r >= 0 && r < this.rows && c >= 0 && c < this.cols && this.board[r][c] === player) {
                    cells.push([r, c]);
                    r += dr;
                    c += dc;
                }
                
                // Check backward direction
                r = row - dr;
                c = col - dc;
                while (r >= 0 && r < this.rows && c >= 0 && c < this.cols && this.board[r][c] === player) {
                    cells.unshift([r, c]);
                    r -= dr;
                    c -= dc;
                }
                
                return cells;
            }

            highlightWinningCells() {
                this.winningCells.forEach(([row, col]) => {
                    const cellIndex = row * this.cols + col;
                    const cell = this.gameBoard.children[cellIndex];
                    const piece = cell.querySelector('.piece');
                    if (piece) {
                        piece.classList.add('winning');
                    }
                });
            }

            isBoardFull() {
                return this.board[0].every(cell => cell !== 0);
            }

            updateStatus() {
                if (BIRDS.length >= 2) {
                    // BIRDS array contains the two rarest birds [0, 1]
                    const bird = BIRDS[this.currentPlayer - 1];
                    this.statusText.textContent = `${bird.name}'s turn`;
                    this.currentPiece.className = `player-piece player${this.currentPlayer}-piece`;
                    this.playerIndicator.classList.remove('hidden');
                } else {
                    this.statusText.textContent = `Player ${this.currentPlayer}'s turn`;
                }
            }

            showWinner() {
                if (BIRDS.length >= 2) {
                    // BIRDS array contains the two rarest birds [0, 1]
                    const bird = BIRDS[this.currentPlayer - 1];
                    this.messageText.textContent = `${bird.name} wins! üéâ`;
                    this.winnerDisplay.innerHTML = `<img src="${bird.imageUrl}" alt="${bird.name}" class="winner-image">`;
                } else {
                    this.messageText.textContent = `Player ${this.currentPlayer} wins! üéâ`;
                    this.winnerDisplay.textContent = '';
                }
                this.gameMessage.classList.add('show');
            }

            showDraw() {
                this.messageText.textContent = "It's a draw! ü§ù";
                this.winnerDisplay.textContent = '';
                this.gameMessage.classList.add('show');
            }

            saveState() {
                // Deep copy current state
                const state = {
                    board: this.board.map(row => [...row]),
                    currentPlayer: this.currentPlayer,
                    gameOver: this.gameOver,
                    winningCells: [...this.winningCells]
                };
                this.stateHistory.push(state);
                
                // Limit history to last 20 moves to save memory
                if (this.stateHistory.length > 20) {
                    this.stateHistory.shift();
                }
                
                this.updateUndoButton();
            }

            undoMove() {
                if (this.stateHistory.length === 0 || this.gameOver) {
                    return; // Nothing to undo or game is over
                }
                
                // Restore previous state
                const previousState = this.stateHistory.pop();
                this.board = previousState.board.map(row => [...row]);
                this.currentPlayer = previousState.currentPlayer;
                this.gameOver = previousState.gameOver;
                this.winningCells = [...previousState.winningCells];
                
                this.renderBoard();
                this.updateStatus();
                this.updateUndoButton();
            }

            renderBoard() {
                // Clear all pieces
                const pieces = this.gameBoard.querySelectorAll('.piece');
                pieces.forEach(piece => piece.remove());
                
                // Re-render all pieces from board state
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        if (this.board[row][col] !== 0) {
                            this.renderPiece(row, col, this.board[row][col]);
                        }
                    }
                }
            }

            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.disabled = this.stateHistory.length === 0 || this.gameOver;
                    undoBtn.style.opacity = (this.stateHistory.length === 0 || this.gameOver) ? '0.5' : '1';
                    undoBtn.style.cursor = (this.stateHistory.length === 0 || this.gameOver) ? 'not-allowed' : 'pointer';
                }
            }

            restart() {
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winningCells = [];
                this.gameMessage.classList.remove('show');
                this.createBoard();
                this.updateStatus();
            }
        }

        // Initialize game
        const game = new ConnectFour();
        game.init();

        // Fullscreen functionality
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Error attempting to enable fullscreen:', err);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function updateFullscreenButton() {
            if (document.fullscreenElement) {
                fullscreenBtn.textContent = '‚õ∂';
                fullscreenBtn.title = 'Exit Fullscreen';
            } else {
                fullscreenBtn.textContent = '‚õ∂';
                fullscreenBtn.title = 'Enter Fullscreen';
            }
        }

        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenButton);
        }

        // Install prompt (PWA)
        let deferredPrompt;
        const installPrompt = document.getElementById('installPrompt');
        const installButton = document.getElementById('installButton');

        // PWA functionality (single-file)
        function setDynamicManifest(manifestObject) {
            const manifestBlob = new Blob([JSON.stringify(manifestObject)], { type: 'application/json' });
            const manifestURL = URL.createObjectURL(manifestBlob);
            const manifestLink = document.getElementById('manifest-placeholder');
            if (manifestLink) {
                manifestLink.setAttribute('href', manifestURL);
            }
        }

        function buildInlineServiceWorkerCode({ cacheName }) {
            return `
                const CACHE_NAME = '${cacheName}';
                const ALLOWED_ORIGINS = [self.location.origin, 'https://birdnet.cornell.edu'];
                const API_PATH = '/api2/requeststats';
                const BIRD_IMAGE_PREFIX = '/api2/bird/';

                self.addEventListener('install', () => self.skipWaiting());

                self.addEventListener('activate', (event) => {
                    event.waitUntil((async () => {
                        const keys = await caches.keys();
                        await Promise.all(keys.map((key) => (key === CACHE_NAME ? Promise.resolve() : caches.delete(key))));
                        await clients.claim();
                    })());
                });

                async function cacheFirst(request) {
                    const cached = await caches.match(request);
                    if (cached) return cached;
                    const response = await fetch(request);
                    const cache = await caches.open(CACHE_NAME);
                    cache.put(request, response.clone());
                    return response;
                }

                async function networkFirst(request) {
                    try {
                        const response = await fetch(request);
                        const cache = await caches.open(CACHE_NAME);
                        cache.put(request, response.clone());
                        return response;
                    } catch (err) {
                        const cached = await caches.match(request);
                        if (cached) return cached;
                        throw err;
                    }
                }

                async function staleWhileRevalidate(request) {
                    const cached = await caches.match(request);
                    const fetchPromise = fetch(request).then(async (response) => {
                        const cache = await caches.open(CACHE_NAME);
                        cache.put(request, response.clone());
                        return response;
                    }).catch(() => null);
                    return cached || (await fetchPromise);
                }

                self.addEventListener('fetch', (event) => {
                    const request = event.request;
                    if (request.method !== 'GET') return;

                    const url = new URL(request.url);
                    if (!ALLOWED_ORIGINS.includes(url.origin)) return;

                    if (url.origin === 'https://birdnet.cornell.edu' && url.pathname === API_PATH) {
                        event.respondWith(networkFirst(request));
                        return;
                    }

                    if (url.origin === 'https://birdnet.cornell.edu' && url.pathname.startsWith(BIRD_IMAGE_PREFIX)) {
                        event.respondWith(cacheFirst(request));
                        return;
                    }

                    event.respondWith(staleWhileRevalidate(request));
                });
            `;
        }

        async function registerInlineServiceWorker({ cacheName, logLabel }) {
            if (!('serviceWorker' in navigator)) return;
            try {
                const swCode = buildInlineServiceWorkerCode({ cacheName });
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(swBlob);
                await navigator.serviceWorker.register(swURL);
                console.log(`${logLabel}: Service Worker registered`);
            } catch (error) {
                console.log(`${logLabel}: Service Worker registration failed:`, error);
            }
        }

        setDynamicManifest({
            name: 'BirdNET Connect Four',
            short_name: 'Connect Four',
            description: 'Connect four birds in a row - BirdNET themed game',
            start_url: './connect4.html',
            display: 'standalone',
            background_color: '#ffffff',
            theme_color: BIRDNET.themeColor,
            orientation: 'portrait',
            icons: [
                {
                    src: BIRDNET.iconUrl,
                    sizes: '512x512',
                    type: 'image/png',
                    purpose: 'any maskable'
                }
            ]
        });

        registerInlineServiceWorker({ cacheName: 'birdnet-connect4-v1', logLabel: 'BirdNET Connect Four' });

        if (installPrompt && installButton) {
            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                installPrompt.classList.add('show');
            });

            installButton.addEventListener('click', async () => {
                if (!deferredPrompt) return;

                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;

                if (outcome === 'accepted') {
                    installPrompt.classList.remove('show');
                }

                deferredPrompt = null;
            });

            window.addEventListener('appinstalled', () => {
                installPrompt.classList.remove('show');
                deferredPrompt = null;
            });
        }
    </script>
</body>
</html>
