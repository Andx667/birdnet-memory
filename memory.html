<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#1976d2">
    <meta name="description" content="BirdNET Memory Game - Match bird pairs using AI-powered bioacoustic knowledge">
    <title>BirdNET Memory Game</title>
    
    <link rel="manifest" href="#" id="manifest-placeholder">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica', 'Arial', sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            min-height: 100dvh; /* Dynamic viewport height for mobile */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: clamp(10px, 2vw, 30px);
            color: #333;
            overflow-x: hidden;
        }

        .container {
            max-width: min(1400px, 95vw);
            width: 100%;
            display: flex;
            gap: clamp(15px, 2vw, 25px);
            align-items: flex-start;
        }

        header {
            background: white;
            padding: clamp(15px, 2vw, 25px);
            border-radius: clamp(6px, 1vw, 12px);
            border: 1px solid #e0e0e0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
            flex: 0 0 auto;
            width: clamp(220px, 28vw, 320px);
            position: sticky;
            top: 20px;
            align-self: flex-start;
        }

        h1 {
            color: #1976d2;
            margin-bottom: 3px;
            font-size: clamp(1.1rem, 3vw, 2rem);
            font-weight: 600;
            letter-spacing: -0.5px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: clamp(6px, 1vw, 10px);
            flex-wrap: wrap;
        }

        .logo {
            width: clamp(28px, 4vw, 48px);
            height: clamp(28px, 4vw, 48px);
            object-fit: contain;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: clamp(8px, 1.5vw, 12px);
            margin-bottom: clamp(12px, 2vw, 20px);
        }

        .stats {
            display: flex;
            flex-direction: column;
            gap: clamp(10px, 2vw, 15px);
            font-size: clamp(0.9rem, 1.8vw, 1.1rem);
            color: #333;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: clamp(8px, 1.5vw, 12px);
            background: #f8f9fa;
            border-radius: 6px;
        }

        .stat-label {
            font-size: clamp(0.7rem, 1.3vw, 0.9rem);
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .stat-value {
            font-weight: 600;
            font-size: clamp(1rem, 2vw, 1.5rem);
            color: #1976d2;
        }

        button {
            padding: clamp(10px, 1.5vw, 14px) clamp(16px, 2.5vw, 24px);
            font-size: clamp(13px, 1.8vw, 18px);
            border: 1px solid #1976d2;
            border-radius: clamp(4px, 0.8vw, 8px);
            cursor: pointer;
            background: #1976d2;
            color: white;
            transition: all 0.2s;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(25, 118, 210, 0.2);
            touch-action: manipulation;
            min-height: 40px; /* Minimum touch target size */
        }

        button:hover {
            background: #1565c0;
            border-color: #1565c0;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(25, 118, 210, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        select {
            padding: clamp(10px, 1.5vw, 14px) clamp(12px, 2vw, 16px);
            font-size: clamp(13px, 1.8vw, 18px);
            border: 1px solid #ddd;
            border-radius: clamp(4px, 0.8vw, 8px);
            cursor: pointer;
            background: white;
            color: #333;
            font-weight: 500;
            min-height: 40px; /* Minimum touch target size */
        }

        select:hover {
            border-color: #1976d2;
        }

        select:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 2px rgba(25, 118, 210, 0.1);
        }

        .game-board {
            display: grid;
            gap: clamp(8px, 1.2vw, 15px);
            padding: clamp(15px, 2vw, 25px);
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: clamp(6px, 1vw, 12px);
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex: 1;
            min-width: 0;
        }

        /* Grid layouts for different card counts */
        .game-board[data-cards="12"] { grid-template-columns: repeat(4, 1fr); }
        .game-board[data-cards="16"] { grid-template-columns: repeat(4, 1fr); }
        .game-board[data-cards="20"] { grid-template-columns: repeat(5, 1fr); }
        .game-board[data-cards="24"] { grid-template-columns: repeat(6, 1fr); }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            .game-board[data-cards="20"] { grid-template-columns: repeat(4, 1fr); }
            .game-board[data-cards="24"] { grid-template-columns: repeat(4, 1fr); }
        }

        @media (max-width: 480px) {
            .game-board[data-cards="12"] { grid-template-columns: repeat(3, 1fr); }
            .game-board[data-cards="16"] { grid-template-columns: repeat(4, 1fr); }
            .game-board[data-cards="20"] { grid-template-columns: repeat(4, 1fr); }
            .game-board[data-cards="24"] { grid-template-columns: repeat(4, 1fr); }
        }

        .card {
            aspect-ratio: 1;
            background: linear-gradient(135deg, #1976d2 0%, #2196f3 100%);
            border-radius: clamp(4px, 1vw, 10px);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(2rem, 5vw, 5rem);
            transition: transform 0.2s;
            position: relative;
            transform-style: preserve-3d;
            box-shadow: 0 2px 4px rgba(0,0,0,0.15);
            border: 1px solid #e3f2fd;
            touch-action: manipulation;
            min-width: 70px;
            min-height: 70px;
            max-height: 18vh;
            width: 100%;
        }

        .card:hover:not(.flipped):not(.matched) {
            transform: scale(1.05);
        }

        .card.flipped {
            animation: flip 0.6s;
        }

        .card.matched {
            animation: match 0.5s;
            opacity: 0.6;
            cursor: default;
        }

        .card-front, .card-back {
            position: absolute;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            backface-visibility: hidden;
        }

        .card-front {
            background: linear-gradient(135deg, #1976d2 0%, #2196f3 100%);
            color: white;
            font-size: 0.5em;
            border: 1px solid #e3f2fd;
        }

        .card-logo {
            width: 60%;
            height: 60%;
            object-fit: contain;
        }

        .card-back {
            background: white;
            border: 2px solid #1976d2;
            transform: rotateY(180deg);
            flex-direction: column;
            padding: clamp(6px, 1vw, 10px);
        }

        .bird-image {
            max-width: 100%;
            height: 65%;
            width: auto;
            object-fit: contain;
            border-radius: 6px;
            margin-bottom: clamp(4px, 0.8vw, 8px);
        }

        .bird-name {
            font-size: clamp(0.45rem, 1.2vw, 0.75rem);
            color: #555;
            text-align: center;
            line-height: 1.1;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
            word-wrap: break-word;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            max-height: 2.2em;
        }

        .card.flipped .card-front {
            transform: rotateY(180deg);
        }

        .card.flipped .card-back {
            transform: rotateY(0deg);
        }

        @keyframes flip {
            0%, 100% { transform: scale(1) rotateY(0deg); }
            50% { transform: scale(1.1) rotateY(90deg); }
        }

        @keyframes match {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
        }

        .victory-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .victory-modal.show {
            display: flex;
            animation: fadeIn 0.3s;
        }

        .modal-content {
            background: white;
            border: 1px solid #e0e0e0;
            padding: clamp(25px, 5vw, 50px);
            border-radius: clamp(6px, 1vw, 12px);
            text-align: center;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: scaleIn 0.5s;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-content h2 {
            color: #1976d2;
            font-size: clamp(1.5rem, 5vw, 3rem);
            margin-bottom: clamp(15px, 3vw, 25px);
            font-weight: 600;
        }

        .modal-content p {
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            margin-bottom: clamp(8px, 1.5vw, 15px);
            color: #333;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes scaleIn {
            from { transform: scale(0.8); }
            to { transform: scale(1); }
        }

        .back-link {
            display: inline-block;
            margin-bottom: 15px;
            color: #1976d2;
            text-decoration: none;
            font-weight: 500;
            font-size: clamp(0.85rem, 1.8vw, 1rem);
        }

        .back-link:hover {
            text-decoration: underline;
        }

        footer {
            color: #666;
            text-align: center;
            padding: clamp(15px, 2vw, 25px);
            font-size: clamp(0.75rem, 1.8vw, 1.1rem);
            line-height: 1.6;
        }

        footer a {
            color: #1976d2;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .footer-line {
            margin-top: 5px;
        }

        .footer-status {
            font-size: 0.85em;
        }

        .footer-source {
            font-size: 0.8em;
        }

        .game-info-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 15px;
            font-size: 0.85rem;
            color: #555;
            line-height: 1.4;
            text-align: left;
        }

        .hidden {
            display: none !important;
        }

        #twoPlayerResults p:first-child {
            font-size: 1.5em;
            margin-bottom: 15px;
        }

        #twoPlayerResults p:last-child {
            margin-top: 10px;
        }

        .install-prompt {
            background: #e3f2fd;
            border: 1px solid #1976d2;
            color: #333;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
        }

        .install-prompt.show {
            display: block;
        }

        .install-prompt button {
            margin-top: 10px;
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        .fullscreen-fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            background: #1976d2;
            border: none;
            border-radius: 50%;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s;
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            touch-action: manipulation;
        }

        .fullscreen-fab:hover {
            background: #1565c0;
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
        }

        .fullscreen-fab:active {
            transform: scale(0.95);
        }

        .loading-message {
            text-align: center;
            padding: 40px;
            color: #888;
            grid-column: 1/-1;
        }

        .player-stats {
            display: none;
        }

        .player-stats.active {
            display: block;
        }

        .current-turn {
            text-align: center;
            margin: clamp(12px, 2vw, 20px) 0;
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            font-weight: 600;
            color: #1976d2;
        }

        .player-scores {
            display: flex;
            flex-direction: column;
            gap: clamp(10px, 2vw, 15px);
        }

        .player-score {
            transition: transform 0.3s;
            padding: clamp(8px, 1.5vw, 12px);
            background: #f8f9fa;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .player-score.active {
            transform: scale(1.1);
        }

        .player-label {
            font-weight: 600;
            font-size: clamp(1rem, 2vw, 1.3rem);
        }

        .player1-label {
            color: #1976d2;
        }

        .player2-label {
            color: #42a5f5;
        }

        .player-value {
            font-size: clamp(1.5rem, 3vw, 2.5rem);
            font-weight: bold;
            color: #333;
        }

        .emoji-fallback {
            display: none;
            font-size: 1em;
        }

        .bird-emoji {
            font-size: 1em;
        }

        /* Additional responsive adjustments for very small screens */
        @media (max-width: 400px) {
            body { padding: 8px; }
            .game-board { padding: 8px; gap: 4px; }
            .card { min-width: 50px; min-height: 50px; }
        }
        
        /* Revert to vertical layout on medium and smaller screens */
        @media (max-width: 1024px) {
            .container {
                flex-direction: column;
            }
            
            header {
                width: 100%;
                position: static;
            }
            
            .controls {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .stats {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .stat-item {
                flex-direction: column;
                min-width: clamp(60px, 15vw, 100px);
            }
            
            .stat-label {
                margin-bottom: clamp(3px, 0.5vw, 5px);
            }
            
            .player-scores {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .player-score {
                flex-direction: column;
                min-width: 120px;
            }
        }
        
        /* Landscape orientation on mobile */
        @media (max-width: 900px) and (orientation: landscape) {
            body { padding: 10px; }
            header { padding: 15px; }
            .game-board { padding: 10px; }
            .modal-content { max-height: 85vh; }
        }
        
        /* Large screens optimization */
        @media (min-width: 1920px) {
            .container { max-width: 1600px; }
        }
        
        /* Extra large displays (65" and above) */
        @media (min-width: 2560px) {
            body { font-size: 20px; }
            .container { max-width: 2000px; }
            button, select { min-height: 60px; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="install-prompt" id="installPrompt">
            <p>üì± Install this app for the best experience!</p>
            <button id="installButton">Install App</button>
        </div>

        <header>
            <a href="index.html" class="back-link">‚Üê Back to Games</a>
            <h1>
                <img src="https://birdnet.cornell.edu/img/logo-birdnet-circle.png" alt="BirdNET Logo" class="logo">
                BirdNET Memory Game
            </h1>
            
            <div class="game-info-box">
                <strong>How to Play:</strong> Flip cards to find matching pairs of birds. Remember their locations!<br>
                <strong>Birds:</strong> Features real bird species from live BirdNET observation data.
            </div>
            
            <div class="controls">
                <select id="gridSize">
                    <option value="12">Easy (12 cards)</option>
                    <option value="16" selected>Medium (16 cards)</option>
                    <option value="20">Hard (20 cards)</option>
                    <option value="24">Expert (24 cards)</option>
                </select>
                <select id="gameMode">
                    <option value="single">Single Player</option>
                    <option value="two">Two Players</option>
                </select>
                <button id="newGameBtn">New Game</button>
            </div>

            <div class="stats" id="statsContainer">
                <div class="stat-item">
                    <span class="stat-label">Moves</span>
                    <span class="stat-value" id="moves">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Time</span>
                    <span class="stat-value" id="timer">0:00</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Matches</span>
                    <span class="stat-value" id="matches">0</span>
                </div>
            </div>
            
            <div class="player-stats" id="playerStats">
                <div class="current-turn" id="currentTurn"></div>
                <div class="player-scores">
                    <div class="player-score" id="player1Score">
                        <div class="player-label player1-label">Player 1</div>
                        <div class="player-value">0</div>
                    </div>
                    <div class="player-score" id="player2Score">
                        <div class="player-label player2-label">Player 2</div>
                        <div class="player-value">0</div>
                    </div>
                </div>
            </div>
        </header>

        <div class="game-board" id="gameBoard"></div>
    </div>

    <div class="victory-modal" id="victoryModal">
        <div class="modal-content">
            <h2 id="victoryTitle">üéâ Congratulations! üéâ</h2>
            <div id="singlePlayerResults">
                <p>You won!</p>
                <p>Moves: <strong id="finalMoves">0</strong></p>
                <p>Time: <strong id="finalTime">0:00</strong></p>
            </div>
            <div id="twoPlayerResults" class="hidden">
                <p id="winnerText"></p>
                <p>Player 1: <strong id="finalPlayer1Score">0</strong> pairs</p>
                <p>Player 2: <strong id="finalPlayer2Score">0</strong> pairs</p>
                <p>Time: <strong id="finalTime2">0:00</strong></p>
            </div>
            <button id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <button class="fullscreen-fab" id="fullscreenBtn" title="Toggle Fullscreen">‚õ∂</button>

    <footer>
        <p>Match the bird pairs to win! Inspired by <a href="https://birdnet.cornell.edu" target="_blank">BirdNET</a></p>
        <p class="footer-line footer-status" id="dataSource">Loading bird observations...</p>
        <p class="footer-line footer-source">Data source: <a href="https://birdnet.cornell.edu/api2/requeststats" target="_blank">BirdNET API</a></p>
        <p class="footer-line">This project is open source on <a href="https://github.com/Andx667/birdnet-games" target="_blank">GitHub</a></p>
    </footer>

    <script>
        // Bird data will be loaded from BirdNET API
        let BIRDS = [];
        let BIRD_DATA_SOURCE = 'Loading...';

        // Fallback bird emojis if API fails
        const FALLBACK_BIRDS = [
            'ü¶Ö', 'ü¶Ü', 'ü¶â', 'ü¶ö', 'ü¶ú', 'ü¶¢', 'üïäÔ∏è', 'ü¶É',
            'üê¶', 'üêß', 'ü¶©', 'üêî', 'üêì', 'ü¶§', 'ü™∂', 'ü¶á'
        ];

        const BIRDNET = {
            apiUrl: 'https://birdnet.cornell.edu/api2/requeststats',
            iconUrl: 'https://birdnet.cornell.edu/img/logo-birdnet-circle.png',
            themeColor: '#1976d2'
        };

        const BIRDNET_DATA_WINDOW_HOURS = 24;

        function setFooterDataSourceText(text) {
            const sourceElement = document.getElementById('dataSource');
            if (sourceElement) {
                sourceElement.textContent = text;
            }
        }

        function formatBirdnetLiveData({ totalObservations, uniqueSpecies, hours = BIRDNET_DATA_WINDOW_HOURS }) {
            const safeHours = Number.isFinite(hours) && hours > 0 ? Math.round(hours) : BIRDNET_DATA_WINDOW_HOURS;
            const obsText = Number.isFinite(totalObservations) ? totalObservations.toLocaleString() : '0';
            const speciesText = Number.isFinite(uniqueSpecies) ? uniqueSpecies.toLocaleString() : '0';
            return `Live data from BirdNET (${obsText} observations, ${speciesText} species in last ${safeHours}h)`;
        }

        // Fetch most common bird observations from BirdNET API
        async function fetchBirdData() {
            try {
                const response = await fetch(BIRDNET.apiUrl);
                const data = await response.json();
                
                // Extract observations array and count species occurrences
                const observations = data.observations || [];
                const speciesMap = {};
                
                observations.forEach(obs => {
                    const species = obs.species;
                    if (species) {
                        const [commonName, scientificName] = species.split(';');
                        if (!speciesMap[commonName]) {
                            speciesMap[commonName] = {
                                name: commonName,
                                scientificName: scientificName,
                                count: 0
                            };
                        }
                        speciesMap[commonName].count++;
                    }
                });
                
                // Sort by count (most common first)
                const speciesData = Object.values(speciesMap)
                    .sort((a, b) => b.count - a.count);
                
                if (speciesData.length > 0) {
                    // Get top species and create bird representations with images
                    BIRDS = speciesData.slice(0, 16).map(species => ({
                        name: species.name,
                        scientificName: species.scientificName,
                        imageUrl: `https://birdnet.cornell.edu/api2/bird/${encodeURIComponent(species.scientificName)}.webp`,
                        count: species.count,
                        useImage: true
                    }));
                    
                    const totalObservations = observations.length;
                    const uniqueSpecies = speciesData.length;
                    BIRD_DATA_SOURCE = formatBirdnetLiveData({ totalObservations, uniqueSpecies, hours: BIRDNET_DATA_WINDOW_HOURS });
                } else {
                    useFallbackBirds();
                }
            } catch (error) {
                console.error('Failed to fetch bird data:', error);
                useFallbackBirds();
            }
        }

        function useFallbackBirds() {
            BIRDS = FALLBACK_BIRDS.map((emoji, index) => ({ 
                emoji, 
                name: `Bird ${index + 1}`, 
                count: 0,
                useImage: false
            }));
            BIRD_DATA_SOURCE = 'Using fallback data';
        }

        function getBirdEmoji(speciesName) {
            // Map common bird names to emojis
            const name = speciesName.toLowerCase();
            if (name.includes('owl')) return 'ü¶â';
            if (name.includes('duck')) return 'ü¶Ü';
            if (name.includes('eagle') || name.includes('hawk')) return 'ü¶Ö';
            if (name.includes('swan')) return 'ü¶¢';
            if (name.includes('dove') || name.includes('pigeon')) return 'üïäÔ∏è';
            if (name.includes('parrot') || name.includes('macaw')) return 'ü¶ú';
            if (name.includes('flamingo')) return 'ü¶©';
            if (name.includes('penguin')) return 'üêß';
            if (name.includes('chicken') || name.includes('hen')) return 'üêî';
            if (name.includes('rooster')) return 'üêì';
            if (name.includes('turkey')) return 'ü¶É';
            if (name.includes('peacock')) return 'ü¶ö';
            if (name.includes('dodo')) return 'ü¶§';
            if (name.includes('crow') || name.includes('raven') || name.includes('blackbird')) return 'üê¶‚Äç‚¨õ';
            // Default bird emoji
            return 'üê¶';
        }

        class MemoryGame {
            constructor() {
                this.cards = [];
                this.flippedCards = [];
                this.matchedPairs = 0;
                this.moves = 0;
                this.timer = 0;
                this.timerInterval = null;
                this.isProcessing = false;
                this.gridSize = 16;
                this.gameMode = 'single';
                this.currentPlayer = 1;
                this.player1Score = 0;
                this.player2Score = 0;
                this.dataLoaded = false;
                
                this.initializeElements();
                this.attachEventListeners();
                this.initializeGame();
            }

            async initializeGame() {
                this.gameBoard.innerHTML = '<div class="loading-message">Loading bird data from BirdNET...</div>';
                
                await fetchBirdData();
                this.dataLoaded = true;
                
                this.updateDataSource();
                this.startNewGame();
            }

            updateDataSource() {
                setFooterDataSourceText(BIRD_DATA_SOURCE);
            }

            updateGridLayout() {
                this.gameBoard.setAttribute('data-cards', this.gridSize);
            }

            initializeElements() {
                this.gameBoard = document.getElementById('gameBoard');
                this.movesDisplay = document.getElementById('moves');
                this.timerDisplay = document.getElementById('timer');
                this.matchesDisplay = document.getElementById('matches');
                this.victoryModal = document.getElementById('victoryModal');
                this.gridSizeSelect = document.getElementById('gridSize');
                this.gameModeSelect = document.getElementById('gameMode');
                this.statsContainer = document.getElementById('statsContainer');
                this.playerStats = document.getElementById('playerStats');
                this.currentTurnDisplay = document.getElementById('currentTurn');
                this.player1ScoreDisplay = document.getElementById('player1Score');
                this.player2ScoreDisplay = document.getElementById('player2Score');
            }

            attachEventListeners() {
                document.getElementById('newGameBtn').addEventListener('click', () => this.startNewGame());
                document.getElementById('playAgainBtn').addEventListener('click', () => {
                    this.victoryModal.classList.remove('show');
                    this.startNewGame();
                });
                this.gridSizeSelect.addEventListener('change', (e) => {
                    this.gridSize = parseInt(e.target.value);
                    this.startNewGame();
                });
                this.gameModeSelect.addEventListener('change', (e) => {
                    this.gameMode = e.target.value;
                    this.startNewGame();
                });
            }

            startNewGame() {
                // Don't start game if data isn't loaded yet
                if (!this.dataLoaded) {
                    return;
                }
                
                this.updateGridLayout();
                this.resetGame();
                this.createCards();
                this.renderBoard();
                this.startTimer();
            }

            resetGame() {
                this.cards = [];
                this.flippedCards = [];
                this.matchedPairs = 0;
                this.moves = 0;
                this.timer = 0;
                this.isProcessing = false;
                this.currentPlayer = 1;
                this.player1Score = 0;
                this.player2Score = 0;
                
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
                
                // Toggle UI based on game mode
                if (this.gameMode === 'two') {
                    this.statsContainer.classList.add('hidden');
                    this.playerStats.classList.add('active');
                } else {
                    this.statsContainer.classList.remove('hidden');
                    this.playerStats.classList.remove('active');
                }
                
                this.updateDisplay();
            }

            createCards() {
                const pairsNeeded = this.gridSize / 2;
                const selectedBirds = BIRDS.slice(0, pairsNeeded);
                
                // Create pairs with unique pair IDs
                const cardPairs = [];
                selectedBirds.forEach((birdData, pairIndex) => {
                    cardPairs.push({ bird: birdData, pairId: pairIndex });
                    cardPairs.push({ bird: birdData, pairId: pairIndex });
                });
                
                // Shuffle cards
                this.cards = this.shuffle(cardPairs).map((cardData, index) => ({
                    id: index,
                    bird: cardData.bird,
                    pairId: cardData.pairId,
                    flipped: false,
                    matched: false
                }));
            }

            shuffle(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            renderBoard() {
                // Grid columns are now handled by CSS auto-fit for responsive layout
                this.gameBoard.innerHTML = '';
                this.cards.forEach(card => {
                    const cardElement = this.createCardElement(card);
                    this.gameBoard.appendChild(cardElement);
                });
            }

            createCardElement(card) {
                const cardDiv = document.createElement('div');
                cardDiv.className = 'card';
                cardDiv.dataset.id = card.id;
                
                const birdData = card.bird;
                const birdName = birdData.name || '';
                // Smarter truncation: try to break at word boundary
                let displayName = birdName;
                if (birdName.length > 25) {
                    const words = birdName.substring(0, 25).split(' ');
                    if (words.length > 1) {
                        words.pop(); // Remove last partial word
                        displayName = words.join(' ') + '...';
                    } else {
                        displayName = birdName.substring(0, 22) + '...';
                    }
                }
                
                let backContent;
                if (birdData.useImage && birdData.imageUrl) {
                    const fallbackEmoji = getBirdEmoji(birdName);
                    backContent = `
                        <img src="${birdData.imageUrl}" 
                             alt="${birdName}" 
                             class="bird-image" 
                             onerror="this.classList.add('hidden');this.nextElementSibling.classList.remove('hidden');">
                        <div class="emoji-fallback">${fallbackEmoji}</div>
                        <div class="bird-name">${displayName}</div>
                    `;
                } else {
                    const birdEmoji = birdData.emoji || 'üê¶';
                    backContent = `
                        <div class="bird-emoji">${birdEmoji}</div>
                        <div class="bird-name">${displayName}</div>
                    `;
                }
                
                cardDiv.innerHTML = `
                    <div class="card-front">
                        <img src="https://birdnet.cornell.edu/img/logo-birdnet-circle.png" alt="BirdNET" class="card-logo">
                    </div>
                    <div class="card-back">${backContent}</div>
                `;
                
                cardDiv.addEventListener('click', () => this.handleCardClick(card.id));
                
                return cardDiv;
            }

            handleCardClick(cardId) {
                if (this.isProcessing) return;
                
                const card = this.cards[cardId];
                if (card.flipped || card.matched) return;
                
                this.flipCard(cardId);
                this.flippedCards.push(cardId);
                
                if (this.flippedCards.length === 2) {
                    this.moves++;
                    this.updateDisplay();
                    this.checkMatch();
                }
            }

            flipCard(cardId) {
                const card = this.cards[cardId];
                card.flipped = true;
                
                const cardElement = document.querySelector(`[data-id="${cardId}"]`);
                cardElement.classList.add('flipped');
            }

            unflipCard(cardId) {
                const card = this.cards[cardId];
                card.flipped = false;
                
                const cardElement = document.querySelector(`[data-id="${cardId}"]`);
                cardElement.classList.remove('flipped');
            }

            checkMatch() {
                this.isProcessing = true;
                
                const [firstId, secondId] = this.flippedCards;
                const firstCard = this.cards[firstId];
                const secondCard = this.cards[secondId];
                
                // Cards match if they have the same pairId
                if (firstCard.pairId === secondCard.pairId) {
                    setTimeout(() => {
                        this.handleMatch(firstId, secondId);
                    }, 600);
                } else {
                    setTimeout(() => {
                        this.unflipCard(firstId);
                        this.unflipCard(secondId);
                        this.flippedCards = [];
                        this.isProcessing = false;
                        
                        // Switch players in two-player mode when no match
                        if (this.gameMode === 'two') {
                            this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                            this.updateDisplay();
                        }
                    }, 2000);
                }
            }

            handleMatch(firstId, secondId) {
                this.cards[firstId].matched = true;
                this.cards[secondId].matched = true;
                
                const firstElement = document.querySelector(`[data-id="${firstId}"]`);
                const secondElement = document.querySelector(`[data-id="${secondId}"]`);
                
                firstElement.classList.add('matched');
                secondElement.classList.add('matched');
                
                this.matchedPairs++;
                
                // Award point to current player in two-player mode
                if (this.gameMode === 'two') {
                    if (this.currentPlayer === 1) {
                        this.player1Score++;
                    } else {
                        this.player2Score++;
                    }
                    // Player continues their turn after a match
                }
                
                this.flippedCards = [];
                this.isProcessing = false;
                
                this.updateDisplay();
                
                if (this.matchedPairs === this.gridSize / 2) {
                    this.handleVictory();
                }
            }

            startTimer() {
                this.timerInterval = setInterval(() => {
                    this.timer++;
                    this.updateDisplay();
                }, 1000);
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            updateDisplay() {
                if (this.gameMode === 'single') {
                    this.movesDisplay.textContent = this.moves;
                    this.timerDisplay.textContent = this.formatTime(this.timer);
                    this.matchesDisplay.textContent = `${this.matchedPairs}/${this.gridSize / 2}`;
                } else {
                    this.currentTurnDisplay.textContent = `Player ${this.currentPlayer}'s Turn`;
                    this.player1ScoreDisplay.querySelector('.player-value').textContent = this.player1Score;
                    this.player2ScoreDisplay.querySelector('.player-value').textContent = this.player2Score;
                    
                    // Highlight current player with CSS class
                    if (this.currentPlayer === 1) {
                        this.player1ScoreDisplay.classList.add('active');
                        this.player2ScoreDisplay.classList.remove('active');
                    } else {
                        this.player2ScoreDisplay.classList.add('active');
                        this.player1ScoreDisplay.classList.remove('active');
                    }
                }
            }

            handleVictory() {
                clearInterval(this.timerInterval);
                
                if (this.gameMode === 'single') {
                    document.getElementById('singlePlayerResults').classList.remove('hidden');
                    document.getElementById('twoPlayerResults').classList.add('hidden');
                    document.getElementById('finalMoves').textContent = this.moves;
                    document.getElementById('finalTime').textContent = this.formatTime(this.timer);
                } else {
                    // Two-player mode victory
                    document.getElementById('singlePlayerResults').classList.add('hidden');
                    document.getElementById('twoPlayerResults').classList.remove('hidden');
                    
                    document.getElementById('finalPlayer1Score').textContent = this.player1Score;
                    document.getElementById('finalPlayer2Score').textContent = this.player2Score;
                    document.getElementById('finalTime2').textContent = this.formatTime(this.timer);
                    
                    const winnerText = document.getElementById('winnerText');
                    if (this.player1Score > this.player2Score) {
                        winnerText.textContent = 'üèÜ Player 1 Wins! üèÜ';
                        winnerText.style.color = '#1976d2';
                    } else if (this.player2Score > this.player1Score) {
                        winnerText.textContent = 'üèÜ Player 2 Wins! üèÜ';
                        winnerText.style.color = '#42a5f5';
                    } else {
                        winnerText.textContent = 'ü§ù It\'s a Tie! ü§ù';
                        winnerText.style.color = '#2196f3';
                    }
                }
                
                setTimeout(() => {
                    this.victoryModal.classList.add('show');
                }, 500);
            }
        }

        // Fullscreen functionality
        const fullscreenBtn = document.getElementById('fullscreenBtn');
        
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => {
                    console.log('Error attempting to enable fullscreen:', err);
                });
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        function updateFullscreenButton() {
            if (document.fullscreenElement) {
                fullscreenBtn.textContent = '‚õ∂';
                fullscreenBtn.title = 'Exit Fullscreen';
            } else {
                fullscreenBtn.textContent = '‚õ∂';
                fullscreenBtn.title = 'Enter Fullscreen';
            }
        }

        if (fullscreenBtn) {
            fullscreenBtn.addEventListener('click', toggleFullscreen);
            document.addEventListener('fullscreenchange', updateFullscreenButton);
        }

        // PWA functionality
        let deferredPrompt;
        const installPrompt = document.getElementById('installPrompt');
        const installButton = document.getElementById('installButton');

        function setDynamicManifest(manifestObject) {
            const manifestBlob = new Blob([JSON.stringify(manifestObject)], { type: 'application/json' });
            const manifestURL = URL.createObjectURL(manifestBlob);
            const manifestLink = document.getElementById('manifest-placeholder');
            if (manifestLink) {
                manifestLink.setAttribute('href', manifestURL);
            }
        }

        function buildInlineServiceWorkerCode({ cacheName }) {
            return `
                const CACHE_NAME = '${cacheName}';
                const ALLOWED_ORIGINS = [self.location.origin, 'https://birdnet.cornell.edu'];
                const API_PATH = '/api2/requeststats';
                const BIRD_IMAGE_PREFIX = '/api2/bird/';

                self.addEventListener('install', () => self.skipWaiting());

                self.addEventListener('activate', (event) => {
                    event.waitUntil((async () => {
                        const keys = await caches.keys();
                        await Promise.all(keys.map((key) => (key === CACHE_NAME ? Promise.resolve() : caches.delete(key))));
                        await clients.claim();
                    })());
                });

                async function cacheFirst(request) {
                    const cached = await caches.match(request);
                    if (cached) return cached;
                    const response = await fetch(request);
                    const cache = await caches.open(CACHE_NAME);
                    cache.put(request, response.clone());
                    return response;
                }

                async function networkFirst(request) {
                    try {
                        const response = await fetch(request);
                        const cache = await caches.open(CACHE_NAME);
                        cache.put(request, response.clone());
                        return response;
                    } catch (err) {
                        const cached = await caches.match(request);
                        if (cached) return cached;
                        throw err;
                    }
                }

                async function staleWhileRevalidate(request) {
                    const cached = await caches.match(request);
                    const fetchPromise = fetch(request).then(async (response) => {
                        const cache = await caches.open(CACHE_NAME);
                        cache.put(request, response.clone());
                        return response;
                    }).catch(() => null);
                    return cached || (await fetchPromise);
                }

                self.addEventListener('fetch', (event) => {
                    const request = event.request;
                    if (request.method !== 'GET') return;

                    const url = new URL(request.url);
                    if (!ALLOWED_ORIGINS.includes(url.origin)) return;

                    if (url.origin === 'https://birdnet.cornell.edu' && url.pathname === API_PATH) {
                        event.respondWith(networkFirst(request));
                        return;
                    }

                    if (url.origin === 'https://birdnet.cornell.edu' && url.pathname.startsWith(BIRD_IMAGE_PREFIX)) {
                        event.respondWith(cacheFirst(request));
                        return;
                    }

                    event.respondWith(staleWhileRevalidate(request));
                });
            `;
        }

        async function registerInlineServiceWorker({ cacheName, logLabel }) {
            if (!('serviceWorker' in navigator)) return;
            try {
                const swCode = buildInlineServiceWorkerCode({ cacheName });
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(swBlob);
                await navigator.serviceWorker.register(swURL);
                console.log(`${logLabel}: Service Worker registered`);
            } catch (error) {
                console.log(`${logLabel}: Service Worker registration failed:`, error);
            }
        }

        // Create manifest dynamically
        setDynamicManifest({
            name: 'BirdNET Memory Game',
            short_name: 'BirdNET Memory',
            description: 'AI-powered memory game - Match bird pairs using BirdNET knowledge',
            start_url: './',
            display: 'standalone',
            background_color: '#ffffff',
            theme_color: BIRDNET.themeColor,
            orientation: 'portrait',
            icons: [
                {
                    src: BIRDNET.iconUrl,
                    sizes: '512x512',
                    type: 'image/png',
                    purpose: 'any maskable'
                }
            ]
        });

        registerInlineServiceWorker({ cacheName: 'bird-memory-v1', logLabel: 'BirdNET Memory' });

        // Install prompt
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installPrompt.classList.add('show');
        });

        installButton.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            
            deferredPrompt.prompt();
            const { outcome } = await deferredPrompt.userChoice;
            
            if (outcome === 'accepted') {
                installPrompt.classList.remove('show');
            }
            
            deferredPrompt = null;
        });

        window.addEventListener('appinstalled', () => {
            installPrompt.classList.remove('show');
            deferredPrompt = null;
        });

        // Initialize game
        const game = new MemoryGame();
    </script>
</body>
</html>